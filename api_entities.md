# Проектирование сущностей API для витрины расчётов с курьерами

## 1. Список полей, необходимых для витрины

Витрина расчётов с курьерами (`cdm.dm_courier_ledger`) требует следующие поля:

| Название поля | Тип | Описание |
|---------------|-----|----------|
| courier_id | integer | Уникальный идентификатор курьера |
| courier_name | text | Имя курьера |
| settlement_year | integer | Год расчётного периода |
| settlement_month | integer | Месяц расчётного периода (1-12) |
| orders_count | integer | Общее количество заказов, доставленных курьером за период |
| orders_total_sum | numeric(10,2) | Общая сумма всех заказов |
| rate_avg | numeric(3,2) | Средний рейтинг, выставленный клиентами (0-5) |
| order_processing_fee | numeric(10,2) | Комиссия за обработку (25% от общей суммы) |
| courier_order_sum | numeric(10,2) | Общая сумма заказов курьера |
| courier_tips_sum | numeric(10,2) | Общая сумма чаевых, полученных курьером |
| courier_reward_sum | numeric(10,2) | Рассчитанное вознаграждение на основе уровней рейтинга |

### Правила расчёта вознаграждения:
- Рейтинг < 4.0: 5% от суммы заказов (минимум 100)
- Рейтинг 4.0-4.5: 7% от суммы заказов (минимум 150)
- Рейтинг 4.5-4.9: 8% от суммы заказов (минимум 175)
- Рейтинг ≥ 4.9: 10% от суммы заказов (минимум 200)

## 2. Список таблиц в слое DDS

### Существующие таблицы (уже есть в репозитории):
✅ **dds.dm_couriers**
- id (serial primary key)
- _id (varchar) - внешний ID курьера из API
- name (varchar) - имя курьера

✅ **dds.dm_deliveries**
- id (serial primary key)
- order_id (varchar) - идентификатор заказа
- order_ts (timestamp) - временная метка заказа
- delivery_id (varchar) - идентификатор доставки
- courier_id (integer) - FK на dds.dm_couriers
- address (text) - адрес доставки
- delivery_ts (timestamp) - временная метка доставки
- rate (integer) - оценка клиента (1-5)
- sum (numeric) - сумма заказа
- tip_sum (numeric) - сумма чаевых

### Таблицы, которые уже существуют (не используются напрямую, но являются частью экосистемы):
✅ **dds.dm_orders** - Измерение заказов
✅ **dds.dm_restaurants** - Измерение ресторанов
✅ **dds.dm_timestamps** - Измерение времени
✅ **dds.dm_users** - Измерение пользователей
✅ **dds.dm_products** - Измерение продуктов
✅ **dds.fct_product_sales** - Таблица фактов продаж продуктов

## 3. Сущности и поля API для загрузки

На основе требований DDS необходимо загрузить следующие данные из API:

### Эндпоинт API: `/couriers`
**Назначение**: Загрузка справочных данных курьеров
**Целевая таблица STG**: `stg.couriers`
**Целевая таблица DDS**: `dds.dm_couriers`

Поля для извлечения:
- `_id` (string) - Уникальный идентификатор курьера
- `name` (string) - Полное имя курьера

### Эндпоинт API: `/deliveries`
**Назначение**: Загрузка транзакционных данных о доставках
**Целевая таблица STG**: `stg.deliveries`
**Целевая таблица DDS**: `dds.dm_deliveries`

Поля для извлечения:
- `order_id` (string) - Идентификатор заказа
- `order_ts` (string) - Временная метка заказа (формат ISO)
- `delivery_id` (string) - Уникальный идентификатор доставки
- `courier_id` (string) - Ссылка на `_id` курьера
- `address` (string) - Адрес доставки
- `delivery_ts` (string) - Временная метка завершения доставки (формат ISO)
- `rate` (integer) - Оценка клиента (шкала 1-5)
- `sum` (numeric) - Общая сумма заказа
- `tip_sum` (numeric) - Сумма чаевых, переданных курьеру

## Архитектура потоков данных

```
API → Слой STG → Слой DDS → Слой CDM
      
/couriers → stg.couriers → dds.dm_couriers ↘
                                             → cdm.dm_courier_ledger
/deliveries → stg.deliveries → dds.dm_deliveries ↗
```

## Примечания по реализации

1. **Инкрементальная загрузка**: Система должна поддерживать инкрементальные обновления для обработки новых доставок и информации о курьерах.

2. **Качество данных**:
   - Убедиться, что курьер существует в `dds.dm_couriers` перед загрузкой доставок
   - Проверить, что значения рейтинга находятся в диапазоне 1-5
   - Убедиться, что все денежные значения неотрицательные

3. **Логика агрегации**: Слой CDM агрегирует данные по курьеру и месяцу, рассчитывая метрики и вознаграждения на основе производительности.

4. **Идемпотентность**: Использование конструкций `ON CONFLICT` гарантирует, что пайплайн можно безопасно перезапускать без создания дубликатов.
